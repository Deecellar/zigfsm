**zigfsm** is a [finite state machine](https://en.wikipedia.org/wiki/Finite-state_machine) library for Zig.

This library tracks [Zig master](https://github.com/ziglang/zig)

Automata-based programming can often lead to simple and robust solutions, usually in self-contained parts of an applications. Many real-world processes, algorithms, and protocols have rigorously defined state machines available. Translating these into programmatic FSMs is often surprisingly easy.

## Features
* State transitions can be triggered manually or through events.
* Transition listeners can add functionality and cancel transitions.
* State machines can export themselves to the Graphviz DOT format.
* State machines can be constructed programmatically, or by importing Graphviz text.
* Comprehensive test coverage, including a Moore machine, a DFA and a CSV parser.

## Documentation

Before diving into code, it's worth repeating that zigfsm state machines can generate their own diagram. This can be immensely helpful when working on your own state machines,
as you get a simple visualization of all transitions and triggers. Obviously, the diagrams can be used as part of your documentation as well.

Here's the diagram from the CSV parser test, as generated by the library:

![csv](https://user-images.githubusercontent.com/34946442/150114019-8dc15ab1-35b9-4631-98b4-976dbb1217c3.png)

Diagrams can be exported to any writer using `exportGraphviz(...)`, which accepts `StateMachine.ExportOptions` to change style and layout.

A png can be produced using the following command: `dot -Tpng csv.gv -o csv.png`

**Please see the test suite for complete examples.**

### Importing the library

Add zigfsm as a [Zig package](https://ziglearn.org/chapter-3) in your build file, or simply import it directly after vendoring/adding a submodule:

```zig
const fsm = @import("zigfsm/main.zig");
```

### Creating a state machine type

A state machine type is defined using state-enums and, optionally, trigger-enums (sometimes called events in the literature)

Here we create an FSM for a button that can be clicked to flip between on and off states:

```zig
const State = enum { on, off };
const Trigger = enum { click };
const FSM = fsm.StateMachine(State, Trigger);
```

If you don't need triggers/events, simply pass null:

```zig
const FSM = fsm.StateMachine(State, null);
```

### Defining state transitions
Now that we have a state machine *type*, let's create an instance with an initial state `.off`:

```zig
var sm = try FSM.init(allocator, .off);
defer sm.deinit();
```

Next, create valid state transitions:

```zig
try sm.addTransition(.on, .off);
try sm.addTransition(.off, .on);
```

### Optionally defining triggers

While `transitionTo` can now be used to change state, it's also common to invoke state transitions
using triggers. This can vastly simplify using and reasoning about your state machine.

The same trigger can cause different transitions to happen, depending on the current state.

Let's define what `.click` means for the on and off states:

```zig
try sm.addTrigger(.click, .on, .off);
try sm.addTrigger(.click, .off, .on);
```

This expresses that if `.click` happens in the `.on` state, then transition to the `.off` state, and vice versa.

### Defining transitions and triggers at the same time
A helper function is available to define triggers and state transitions at the same time:

```zig
try sm.addTriggerAndTransition(.click, .on, .off);
try sm.addTriggerAndTransition(.click, .off, .on);
```

Which approach to use depends on the application.

### Changing state

Let's flip the lights on by directly transitioning to the on state:

```zig
try sm.transitionTo(.on);
```

This will fail with `StateError.Invalid` if the transition is not valid.

Next, let's change state using the click trigger. In fact, let's do it several times, flipping the switch off and on and off again:

```zig
try sm.activateTrigger(.click);
try sm.activateTrigger(.click);
try sm.activateTrigger(.click);
```

Again, this will fail with `StateError.Invalid` if a transition is not valid.

Finally, it's possible to change state through the more generic `apply` function, which takes either a new state or a trigger.

```zig
try sm.apply(.{ .state = .on });
try sm.apply(.{ .trigger = .click });
```

### Probing the current state

The current state is available through `currentState()`. To check if the current state is a specific state, call `isCurrently(...)`

If final states have been added through `addFinalState(...)`, you can check if the current state is in a final state by calling `isInFinalState()`

To check if the current state is in the start state, call `isInStartState()`

See the API docstring for more information about these are related functions.

### Transition handlers

In many non-trivial applications, especially when using triggers, you might want to know when a transition happens. Or you might need to cancel a transition is specific situations.

Moreover, you might need to keep additional state (such as source locations when writing a parser.) This is where transition handlers are useful.

Let's keep track of the number of times a light switch transition happens:

```zig
var countingHandler = CountingHandler.init();
try sm.addTransitionHandler(&countingHandler.handler);
```

Whenever a transition happens, the handler's `onTransition` function will be called.

To write `CountingHandler`, we have to implement the `Handler` "interface" that zigfsm defines for you.

Because Zig doesn't offer a native way to define or implement interfaces, zigfsm comes with a bit of metaprogramming magic to make this relatively easy:

```zig
    const CountingHandler = struct {
        handler: FSM.Handler,
        counter: usize,

        pub fn init() @This() {
            return .{
                .handler = fsm.Interface.make(FSM.Handler, @This()),
                .counter = 0,
            };
        }

        pub fn onTransition(handler: *FSM.Handler, trigger: ?Trigger, from: State, to: State) HandlerResult {
            const self = fsm.Interface.downcast(@This(), handler);
            self.counter += 1;
            return HandlerResult.Continue;
        }
    };
```

The first field must be the Handler interface, which we populate using `fsm.Interface.make`.

When `onTransition` is called, we "downcast" the handler argument to our specific `CountingHandler` type, which gives us access to the counter.

#### Canceling transitions

The transition handler can conditionally stop a transition from happening by returning `HandlerResult.Cancel`. The callsite of transitionTo or activateTrigger will then fail with `StateError.Invalid`

Alternatively,`HandlerResult.CancelNoError` can be used to cancel without failure (in other words, the current state remains but the callsite succeeds)
